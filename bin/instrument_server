#!/usr/bin/env ruby

require 'rubygems'
begin
  gem 'instrumental_agent'
rescue Gem::LoadError
  puts "Requires the Instrumental Agent gem:\n"
  puts '  gem install instrumental_agent'
  exit 1
end
require 'instrumental_agent'
require 'optparse'
require 'socket'
$: << File.join(File.dirname(__FILE__), "..", "lib")
require 'instrumental_tools/version'
require 'instrumental_tools/server_controller'

def require_api_key(options, parser)
  if options[:api_key].to_s.strip.empty?
    print parser.help
    exit 1
  end
end

options = {
  :daemon          => false,
  :collector       => 'collector.instrumentalapp.com',
  :port            => '8000',
  :hostname        => Socket.gethostname,
  :pid_location    => File.join(Dir.home, 'instrument_server.pid'),
  :log_location    => File.join(Dir.home, 'instrument_server.log'),
  :report_interval => 30
}

option_parser = OptionParser.new do |opts|
  opts.banner = "Usage: instrument_server -k API_KEY [options] [-d #{ServerController::COMMANDS.join('|')}]"

  opts.on('-k', '--api_key API_KEY', 'API key of your project') do |api_key|
    options[:api_key] = api_key
  end

  opts.on('-c', '--collector COLLECTOR[:PORT]', "Collector (default #{options[:collector]}:#{options[:port]})") do |collector|
    address, port = collector.split(':')
    options[:collector] = address
    options[:port] = port if port
  end

  opts.on('-H', '--hostname HOSTNAME', "Hostname to report as (default #{options[:hostname]})") do |hostname|
    options[:hostname] = hostname
  end

  opts.on('-d', '--daemonize', 'Run as daemon') do
    options[:daemon] = true
  end

  opts.on('-p', '--pid LOCATION', "Where daemon PID file is located (default #{options[:pid_location]})") do |pid_location|
    options[:pid_location] = pid_location
  end

  opts.on('-l', '--log LOCATION', "Where to put the instrument_server log file (default #{options[:log_location]})") do |log_location|
    options[:log_location] = log_location
  end

  opts.on('-r', '--report-interval INTERVAL_IN_SECONDS', "How often to report metrics to Instrumental (default #{options[:report_interval]})") do |interval|
    options[:report_interval] = interval.to_i
  end

  opts.on('-h', '--help', 'Display this screen') do
    puts opts
    exit
  end
end

option_parser.parse!

command = ARGV.first && ARGV.first.to_sym
command ||= :start

options[:api_key] ||= ENV["INSTRUMENTAL_TOKEN"]

if options[:pid_location].to_s.strip.empty?
  raise "You must provide a valid path for the PID file (-p PID_PATH)"
end

if !File.exists?(File.dirname(options[:pid_location]))
  raise "The directory specified for the pid file #{options[:pid_location]} does not exist, please create"
end

if options[:log_location].to_s.strip.empty?
  raise "You must provide a valid path for the log file (-l LOG_PATH)"
end

if !File.exists?(File.dirname(options[:log_location]))
  raise "The directory specified for the log file #{options[:log_location]} does not exist, please create"
end

if options[:report_interval].to_i < 1
  raise "You must specify a reporting interval greater than 0"
end

if [:start, :restart].include?(command)
  require_api_key(options, option_parser)
end

running_as_daemon = options[:daemon]

controller = ServerController.spawn(
               :name        => File.basename(__FILE__),
               :path        => Dir.pwd,
               :pid_file    => options[:pid_location],
               :verbose     => true,
               :log_file    => options[:log_location],
               :run_options => options
             )

if ServerController::COMMANDS.include?(command)
  controller.send command
else
  raise "Command must be one of: #{ServerController::COMMANDS.join(', ')}"
end



if running_as_daemon
  begin
    Timeout.timeout(5) do
      Process.waitpid(controller.pid)
    end
  rescue Timeout::Error
  end
  if !controller.running?
    raise "Failed to start process, see #{options[:log_location]}"
  end
end
